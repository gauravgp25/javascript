<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf8">
        <title>Day3 Assignment 2</title>
    </head>
    <body>
        <h3>Name : Gaurav Pati(Gauravgp25)</h3>
        <p>Write a diff between var, let & const with code</p>
        <p>A var variable can be redeclared and updated.</br>
            A let variable be be updated but not redeclared.</br>
            An example of trying to redeclare a let variable:</br>
            // In editor:</br>
            <script></br>
            let points = 50;</br>
            let points = 60;</br>
            </script></br>
            // In the console I get an error:</br>
            Uncaught SyntaxError: Identifier 'points' has already been declared</br>
            However, I can update it:</br>
            let points = 50;</br>
            points = 60;</br>
            // In console:</br>
            points</br>
            // Returns:</br>
            60</br>
            The Scope of let</br>
            If I declare a let variable at the global scope, then redeclare it within a block (curly brackets) as in the example below, I will not get an error in the console, but it will not actually redeclare let.</br>
            let points = 50;</br>
            let winner = false;</br>
            if(points > 40) {</br>
              let winner = true;</br>
            }</br>
            // If I call:</br>
            winner</br>
            // It returns the first value:</br> 
            false</br>
            Why is this happening?</br>
            Because let winner = false and let winner = true, are actually two separate variables because they are scoped differently, even though they have the same name. To clarify:</br>
            // This 'let' is scoped to the window (globally):</br>
        </br>let winner = false;
    </br>if(points > 40) {
    </br>   // This 'let' is scoped to the block (between the curly brackets):
</br>     let winner = true;
</br>       }
</br>       In the above example if we change bothletvariables to var, then call winner in the console it returns true because it is not inside a function. (Remember: var is function scoped.) The var variable is being redeclared within its scope, which is the window in this case.
</br>       let points = 50;
</br>       var winner = false;
</br>       if(points > 40) {
</br>         var winner = true;
</br>       }
</br>       // If I call:
</br>       winner
</br>       // It now returns: 
</br>       true
</br>       The Differences Between let and const
</br>       const variables cannot be updated. let variables are made to be updated.
</br>       // If I define the const variable:
</br>       const key = 'xyz123';
</br>       // Then try to redeclare it:
</br>       key = 'xyz1234'
</br>       // I get the following error:
</br>       Uncaught TypeError: Assignment to constant variable.
</br>       There is an interesting caveat to this, though. If I create a const variable that is an object, the attributes of that object can be updated.
</br>       // Creating my person object:
</br>       const person = {
</br>         name: 'Joseph',
</br>         age: 33
</br>       }
</br>       // Calling person in the console:
</br>       person
</br>       // It returns:
</br>       {name: "Joseph", age: 33}
</br>       // If I then redeclare the age attribute:
</br>       person.age = 34
</br>       // When I call it:
</br>       person
</br>       // It returns:
</br>       {name: "Joseph", age: 34}
</br>       Note: If I want to make object unchangeable I could “freeze” it:
</br>       const joseph = Object.freeze(person);
</br>       If I then try to change an attribute of the person object in my console, it does not take the changes:
</br>       // If I call:
</br>       person
</br>       // It returns:
</br>       {name: "Joseph", age: 33}
</br>       // However, if the object has been 'frozen' and I try to change the age attribute:
</br>       person.age = 34
</br>       // It will immediately return:
</br>       34
</br>       // But then when I call it:
</br>       person.age
</br>       // It returns the original age:
</br>       33
</br>       The advantages of using let vs. var in a for loop
</br>       I’ve run into many issues regarding scope with for loops when defining i with var. This is where using let could prove advantageous.
</br>       // Running a for loop with var:
</br>       for(var i = 0; i < 10; i++){
</br>           console.log(i);
</br>       }
</br>       // Returns 0 through 9 in the console, but if I call:
</br>       i
</br>       // It returns:
</br>       10
</br>       In other words, i has leaked out of the scope of the for loop, and can now be called at the global scope (or whatever the parent scope is)!
</br>       The other issue with using var in a for loop is when you want to do something within the scope of the loop, but after the loop runs. i is being redeclared each time the loop runs.
</br>       // Do something one second after the loop runs:
</br>       for(var i = 0; i < 10; i++) {
</br>           console.log(i);
</br>           setTimeout(function() {
</br>             console.log('The number is ' + i);
</br>           }, 1000);
</br>       }
</br>       // If we then call i in the console it returns:
</br>       10
</br>       Again, the variable i is being overwritten every time the loop runs. By the time setTimeout runs, i is 10.
</br>       A quick way to fix this is the change var to let. Because let is block scoped (within the curly brackets), it will behave differently, and will not reassign i every time the loop runs:
</br>       for(let i = 0; i < 10; i++) {
</br>           console.log(i);
</br>           setTimeout(function() {
</br>             console.log('The number is ' + i);
</br>           }, 1000);
</br>       }
</br>       // This returns 0 through 9 in the console, then after one second logs:
</br>       The number is 0
</br>       The number is 1
</br>       The number is 2
</br>       The number is 3
</br>       The number is 4
</br>       The number is 5
</br>       The number is 6
</br>       The number is 7
</br>       The number is 8
</br>       The number is 9</p>
    </body>
</html>